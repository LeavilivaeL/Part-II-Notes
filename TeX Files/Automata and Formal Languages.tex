\documentclass[10pt,a4paper]{article}
\input{./preamble.tex}

\title{Automata and Formal Languages}
\begin{document}
\maketitle
\section{Register Machines and Computability}
\textbf{\underline{Books:}} PTJ (Chapter 4)

\textsc{Note: Here $\N = \{0,1,2,\ldots\}$}

A \emph{register machine (RM)} consists of:
\begin{enumerate}
\item A sequence of \emph{registers} $R_1, R_2, R_3, \ldots$ where at discrete time steps $t = 0,1,2,\ldots$ have $R_i(t) \in \N$, In fact, we only have finitely many registers, and regard $R_i \equiv 0$ for all $i\geq I$.
\item A finite \emph{program} consisting of a fixed number of \emph{states} $S_0$ (\textsc{Halt}), $S_1$ (\textsc{Start}), $S_2,\ldots, S_n$. Each state comes with a fixed instruction performed when in state $S_i$. When the computer reaches \textsc{Halt}, we get the output from $R_1$. Otherwise, for $1\leq i\leq n$ we have $2$ types of \emph{commands}:
\begin{enumerate}
\item Increment $R_j$, then move to state $S_k$. We write this $S_i:(j,+,k)$.
\item If $R_j \neq 0$ then decrement $R_j$, then move to state $S_k$. Otherwise move to state $S_l$. We write this $S_i:(j,-,k,l)$.
\end{enumerate}
\end{enumerate}

A \emph{sequence of instructions} for a RM is the ordered list of the instructions for the program.\\
An \emph{input} for a RM is, for some $k\geq 1$, a finite $k$-tuple $(n_1,\ldots,n_k)\in\N^k$ which are the initial values of $R_1,\ldots,R_k$. The other registers are set to 0.

A \emph{program diagram} for a RM is a directed graph with vertices being the states of the machine and the labelled arrows denote the instructions: $S_i:(j,+,k) $

\begin{figure}
\begin{subfigure}{.5\textwidth}
\begin{center}
\tikz{
\node (i) at (0,0) [circle, draw] {$S_i$};
\node (k) at (3,0) [circle, draw] {$S_k$};
\draw (i) edge[->] node[above] {$R_j +1$} (k) ;
}
\end{center}
\caption{$S_i:(j,+,k)$}
\end{subfigure}
\begin{subfigure}{.5\textwidth}
\begin{center}
\tikz{
\node (i) at (0,1) [circle, draw] {$S_i$};
\node (k) at (3,1) [circle, draw] {$S_k$};
\node (l) at (3,0) [circle, draw] {$S_l$};
\draw (i) edge[->] node[above, midway] {$R_j -1$} (k);
\draw (i) edge[dashed,->] (l);
}
\end{center}
\caption{$S_i:(j,-,k,l)$}
\end{subfigure}
\end{figure}

We can then use these to describe programs:
\begin{figure}
\begin{subfigure}{.8\textwidth}
\centering
\tikz{
\node (0) at (0,0) [circle, draw] {$S_0$};
\node (1) at (2,0) [circle, draw] {$S_1$};
\draw[->] (1.-60) arc (220:220+285:6mm) node[midway, right] {$R_1 + 1$};
}
\caption{Repeatedly increment $R_1$, never halting}
\end{subfigure}
\begin{subfigure}{.8\textwidth}
\centering
\tikz{
\node (0) at (0,0) [circle, draw] {$S_0$};
\node (1) at (2,0) [circle, draw] {$S_1$};
\node (2) at (4,0) [circle, draw] {$S_2$};
\node (3) at (6,0) [circle, draw] {$S_3$};
\draw (1) edge[bend left,->] node[above] {$R_2-1$} (2);
\draw (2) edge[bend left,->] node[below] {$R_1-1$} (1);
\draw (1) edge[dashed,->] (0);
\draw (2) edge[dashed,->] (3);
\draw[->] (3.-60) arc (220:220+285:6mm) node[right, midway] {$R_1 + 1$};
}
\caption{For input $(n_1,n_2)$ returns $n_1-n_2$ if $n_1\geq n_2$, else never halt}
\end{subfigure}
\begin{subfigure}{.8\textwidth}
\centering
\tikz{
\node (0) at (1,0) [circle, draw] {$S_0$};
\node (1) at (0,1.5) [circle, draw] {$S_1$};
\node (2) at (2,1.5) [circle, draw] {$S_2$};
\node (3) at (4,1.5) [circle, draw] {$S_3$};
\draw[->] (1.120) arc (40:40+285:6mm) node[left, midway] {$R_j - 1$};
\draw[dashed, ->] (1) edge (2);
\draw (2) edge[->, bend left] node[above] {$R_i-1$} (3);
\draw (3) edge[->, bend left] node[below] {$R_j+1$} (2);
\draw (2) edge[->, dashed, bend left] (0);
}
\caption{Transfer $R_i$ to $R_j$, emptying $R_i$}
\end{subfigure}
\end{figure}

For any $k>0$ a program $P$ \emph{halts} on input $(m_1, m_2, \ldots, m_k) \in \N^k$ if it ever reaches state $S_0$, written $P(m_1,\ldots,m_k)\downarrow$\\
The \emph{halting set} $\Omega(P)$ is a set of inputs on which $P$ halts.
\begin{align*}
\Omega(P) = \cup_{k>0} \{(m_1,\ldots,m_k) : P(m_1,\ldots,m_k)\downarrow\}
\end{align*}
If $P$ does not halt, we write $P(m_1,\ldots,m_k)\uparrow$.

For each program $P$, the \emph{upper register index} $\upper(P)$ is the largest index of a register appearing in the instructions for $P$. So if $i>\upper(P)$ then $R_i$ never changes.

A \emph{partial function} $f:\N^k \rightarrow \N$ is one where the domain of $f$ is a subset of $\N^k$, and undefined otherwise. If $f$ is defined everywhere then we call it a \emph{total function}. This lets us define these programs as functions - we say $f$ is \emph{partial computable} by a program $P$ such that $\forall (m_1,\ldots,m_k) \in \dom(f)$ have $P(m_1,\ldots,m_k)\downarrow$ with $f(m_1,\ldots,m_k) = R_1$ on halting, and $\forall (m_1,\ldots,m_k)\notin \dom(f)$ we have $P(m_1,\ldots,m_k)\uparrow$. Hence any program $P$ and $k>0$ gives a partial function $f:\N^k \rightarrow \N$.

\begin{lemma}
We can add $R_i$ to $R_j$ leaving $R_i$ unchanged.
\end{lemma}
\begin{proof}
\item
\centering
\tikz{
\node (1) at (0,4) [circle,draw] {$S_1$};
\node (2) at (2,4) [circle,draw] {$S_2$};
\node (3) at (4,4) [circle,draw] {$S_3$};
\node (4) at (1,2) [circle,draw] {$S_4$};
\node (5) at (3,2) [circle,draw] {$S_5$};
\node (0) at (0,0) [circle,draw] {$S_0$};
\draw (1) edge[->] node[below] {$R_i-1$} (2);
\draw (2) edge[->] node[below] {$R_n+1$} (3);
\draw (1) edge[->, dashed] (4);
\draw (3) edge[->, bend right] node[above] {$R_j+1$} (1);
\draw (4) edge[->, bend left] node[above] {$R_n-1$} (5);
\draw (5) edge[->, bend left] node[below] {$R_i+1$} (4);
\draw (4) edge[->, dashed] (0);
}\\
Thus by setting ($i=2, j=1$) we see that $(n_1, n_2) \mapsto n_1 + n_2$ is total computable.
\end{proof}
We have already seen that the function $n\mapsto 0$ is also computable. This can be done with the machine:
\begin{center}
\tikz{
\node (1) at (0,0) [circle, draw] {$S_1$};
\node (0) at (2,0) [circle, draw] {$S_0$};
\draw (1) edge[->, dashed] (0);
\draw[->] (1.120) arc (40:40+285:6mm) node[left, midway] {$R_1 - 1$};
}
\end{center}
\begin{corollary}
There exists a routine which can copy $R_i$ to $R_j$ leaving $R_i$ unchanged.
\end{corollary}
\begin{proof}
First empty $R_j$, then use \textbf{1.1} to add $R_i$ to $R_j$.
\end{proof}
We can use these as subroutines to join with other programs $P$. Use registers $R_n \st n> \upper(P)$ and largest input register. Then replace the halt state of $P$ with the start state of the subroutine. In fact we have already done this - if you look carefully at the adding machine, you can see that the middle section is the same as the machine in (c) of the examples - this is the part where we replace the value in $R_i$ from its temporary location in $R_n$.

\subsection*{Partial Recursive Functions}
Partial computable functions have good closure properties.
\begin{theorem}
\item
\begin{enumerate}
\item For $i\leq k$, the \emph{projection function} $(n_1, \ldots, n_k) \mapsto n_i$ is computable.
\item The zero function $n\mapsto 0$ and \emph{successor function} $n\mapsto n+1$ are computable
\item (Composition) If $f:\N^k\rightarrow \N$ and $g_1, \ldots, g_k:\N^{l} \rightarrow \N$ are all partial computable then so is the composition function $h(n_1,\ldots,n_l) = f(g_1(n_1,\ldots,n_l),\ldots,g_k(n_1,\ldots,n_l))$ where defined. If $f,g_1,\ldots,g_k$ are total functions, so is $h$.
\item (Recursion) If $f$ on $k$ variables and $g$ on $k+2$ variables are partial computable, then so is the partial function $h:\N^{k+1}\rightarrow \N$ defined inductively as:
\begin{align*}
h(n_1,\ldots,n_k,0)&=f(n_1,\ldots,n_k)\\
h(n_1,\ldots,n_k,n_{k+1}+1) &= g(n_1,\ldots,n_{k+1},h(n_1,\ldots,n_{k+1}))
\end{align*}
Moreover, $f,g$ total $\implies h$ total.
\item (Minimisation) If $f$ on $k+1$ variables is partial computable then so is the partial function $g:\N^k\rightarrow \N$ defined by $g(n_1,\ldots,n_k) = n$ if $f(n_1,\ldots,n_k,n) = 0$ and $f(n_1,\ldots,n_k,m) > 0$ for all $m<n$, and is undefined if no zero is ever found. Note that $f$ total $\nRightarrow g$ total.
\end{enumerate}
\end{theorem}
\begin{proof}\item
\begin{enumerate}
\item We can use the program Transfer $R_i$ to $R_1$, \textsc{Halt}.
\item Zero function has already been seen. For successor function, use:
\begin{center}
\tikz{
\node (1) at (0,0) [circle, draw] {$S_1$};
\node (0) at (2,0) [circle, draw] {$S_2$};
\draw (1) edge[->] node[above] {$R_1 +1$} (0);
}
\end{center}
\item First transfer $R_1,\ldots, R_l$ to $R_{N+1},\ldots, R_{N+l}$ where $N$ is large enough to not be needed in other subroutines. Then for each $1\leq i\leq k$ in turn, copy $R_{N+1}, \ldots, R_{N+l}$ to $R_{k+1},\ldots, R_{k+l}$, perform $g_i$ but with all registers shifted up by $k$ and then transfer answer from $R_{k+1}$ to $R_{i}$, then clear $R_{k+2},\ldots,R_N$. Finally, apply $f$. 
\item Copy $R_1,\ldots,R_k$ to $R_{N+1},\ldots,R_{N+k}$, transfer $R_{k+1}$ to $R_{N+k+2}$ (``counts down"), then do $f$. Then:
\begin{center}
\tikz{
\node (0) at (0,3) [circle, draw] {$\cdot$};
\node[draw] (1) at (7,2) {Transfer $R_1$ to $R_{k+2}$ then copy $R_{N+1},\ldots, R_{N+k+1}$ to $R_1,\ldots,R_{k+1}$};
\node (2) at (5,0) [draw] {\textsc{Halt}$(g)$, clear $R_{k+2},\ldots,R_N$};
\node (3) at (0,0) [draw] {\textsc{Halt}};
\draw (0) edge[->, bend left] node[above] {$R_{N+k+2} -1$} (1);
\draw (1) edge[->] node[right] {$g$} (2);
\draw (2) edge[->, bend left] node[right] {$R_{N+k+1}+1$} (0);
\draw (0) edge[->, dashed] (3);
}
\end{center}
\item Copy $R_1, \ldots, R_k$ to $R_{N+1},\ldots,R_{N+k}$. Then
\begin{center}
\tikz{
\node (0) at (1,2) [circle, draw] {$\cdot$};
\node[draw] (1) at (2,4) {Copy $R_{N+1},\ldots,R_{N+k+1}$ to $R_1,\ldots,R_{k+1}. $ Clear $R_{k+2},\ldots, R_N$};
\node (2) at (2,0) [draw] {\textsc{Halt}$(f)$};
\node (3) at (6,0) [draw] {Transfer $R_{N+k+1}$ to $R_1$, \textsc{Halt}};
\draw (0) edge[->] node[left] {$R_{N+k+1} +1$} (1);
\draw (1) edge[->] node[right] {$f$} (2);
\draw (2) edge[->] node[left] {$R_{i}-1$} (0);
\draw (2) edge[->, dashed] (3);
}
\end{center}
\end{enumerate}
\end{proof}
The class of \emph{partial recursive functions} is the smallest class of partial functions from $\N^k$ to $\N$ over all $k\geq 1$ closed under the operations \textbf{1.3} (1) to (5). That is, $f$ can be constructed from basic functions and applications of $(3), (4), (5)$ a finite number of times.

So \textbf{1.3} says that partial recursive $\implies$ partial computable.

A partial function is \emph{primitive recursive} if we never use \textbf{1.3} (5) its construction. Note that primitive recursive $\implies$ total recursive, as (5) was the only construction that breaks the totality of the function. [The converse implication is not true: the Ackermann function.]

Example: $+$ and $\times$ are primitive recursive:
\begin{itemize}
\item[$+$:] Let $h(m,0) = m$, $h(m,n+1) = h(m,n) + 1 = g(m,n,h(m,n))$, where $g(x,y,z) = z+1$.
\item[$\times$:] $H(m,0) = 0$, $H(m,n+1) = H(m,n) + m = g(m,n,H(m,n))$ for $g(x,y,z) = x+z$.
\end{itemize}
Example: $(m,n)\mapsto m^n$ is primitive recursive - left as exercise.

We need to be able to ``encode" finite sequences of arbitrary length in $\N$. For $n>0$ and $i\in\N$, write $p_i$ for the $(i+1)\th$ prime (so $p_0 = 2$). Write $(n)_i$ for the largest power of the prime $p_i$ that divides $n$.

\begin{lemma}
For each fixed $i$, the 1 variable function $(\cdot)_i : \N \rightarrow \N$ is primitive recursive.
\end{lemma}

\begin{proof}
First note that, for any finite sequence $(m_0, m_1, \ldots, m_s)\subseteq\N^{s+1}$, the function\\ $f(n) = \begin{cases} m_n &n\leq s \\ 0 & n>s \end{cases}$ is primitive recursive.

By induction on $s$ and recursion from \textbf{1.3} \textit{(4)}, for $k=0$ if $c$ constant and $g:\N^2 \rightarrow \N$ is primitive recursive, then so is $h(0) = c, h(n+1) = g(n, h(n))$.

Thus, given $f:\N\rightarrow\N$ primitive recursive, let $g(n,m) \coloneqq f(n)$, which is primitive recursive. So $h(0)=c, h(n+1)=f(n)$ is primitive recursive, and we can repeat this process. 

This includes for each \underline{fixed} k:
\begin{enumerate}
\item The step function $\text{Step}_k(n) = \begin{cases} 1 & 0\leq n\leq k-1 \\ 0 & \text{otherwise} \end{cases}$
\item The delta function $\delta_k(n) = \begin{cases} 1 & n=k \\ 0 & n\neq k\end{cases}$ Let $\epsilon(n) = \delta_0(\delta_0(n)) = \begin{cases} 0 & n=0\\ 1 & n=1\end{cases}$ - this is also primitive recursive.
\item The slope function $\text{Slope}_k(n) = \begin{cases} n+1 & 0\leq n \leq k-2 \\ 0 & \text{otherwise} \end{cases}$
\item The remainder function $\text{Rem}_k(n) = n \mod k$ use recursion in the form $g(n,m) \coloneqq f(m)$, so $h(0) = 0$, $h(n+1)=f(h(n))$ primitive recursive if $f$ is. Here, $\text{Rem}_k(n+1) = \text{Slope}_k(\text{Rem}_k(n))$
\item[*5.] $\text{Floor}_k(n) = \left\lfloor\frac{n}{k}\right\rfloor$
\item[*6.] $\text{Divide}_k(n) = \begin{cases} n/k & n\equiv 0 \mod k \\ 0 & \text{otherwise} \end{cases}$
\item[*7.] Division by powers $\text{Power}_k(n,m) = \begin{cases} n/k^m & n\equiv 0 \mod k^m \\ 0 & \text{otherwise} \end{cases}$
\item[*8.] $\text{Maxpower}_k(n) = \begin{cases} 0 & n=0 \\ \text{largest power of k dividing n} & n\neq 0 \end{cases}$
\end{enumerate}
Proofs of *ed function are on example sheet 1.

Now define by recursion $h(n,0) = 0$ and $h(n,m+1) = h(n,m) + \epsilon(\text{Power}_k(n,m+1))$.\\
$\epsilon(\text{Power}_k(n,j)) = \begin{cases} 1 & k^j \text{ divides } n>0 \\ 0 & \text{otherwise} \end{cases}$, so is $0$ if $j\geq n$

So $h(n,n) = \sum_{i=1}^n \epsilon(\text{Power}_k(n,1)) = \text{Maxpower}_k(n)$, so $h(n,n)$ is primitive recursive.
\end{proof}

\subsection*{Computable = Recursive}
We have seen already that partial recursive $\implies$ partial computable.
\begin{theorem}
Every partial computable function $f:\N^k \rightarrow \N$ is partial recursive.
\end{theorem}
\begin{proof}
From a program $P$ for $f$, define $g:\N^{k+2}\rightarrow \N$, ``what actually goes on in $P$", to be the function:
\begin{center}
$g(n_1,\ldots,n_k,0,t) $ is the state of $P$ after time $t$ with input $(n_1,\ldots,n_k)$
\end{center}
So $t=0$ gives $1$ and if halt at $t_0$ then gives $0$ for all $t \geq t_0$, and:
\begin{center}
$(n_1, \ldots, n_k, i, t)$ is the contents of $R_i$ at time $t$
\end{center}
So have $N$ (assume $>k$) such that $g(\cdots, i, \cdot) = 0 \forall i>N$. Note that $g$ is a total function.

\underline{Suppose} that $g$ is recursive and define $q(n_1,\ldots, n_k) = \min\{t: g(n_1,\ldots,n_k,0,t)=0\}$. Then $q$ is partial recursive, and so $f(n_1, \ldots, n_k) = g(n_1, \ldots, n_k, 1, q(n_1, \ldots, n_k))$ is partial recursive.

\underline{Proof that $g$ is recursive:}\\
Fix $n_1, \ldots, n_k$ and $t$. For each $0\leq i \leq N$, $g$ gives $(g_0, \ldots, g_N) \in \N^{N+1}$, encode as $c(d_0, \ldots, d_N) = 2^{d_0}3^{d_1}\ldots p_N^{d_N} \in \N$ is primitive recursive. Also, $(c(d_0, \ldots, d_N))_i = d_i$ is primitive recursive. We will define $h:\N^{k+2}\rightarrow \N$ via recursion where $h(n_0, n_1, \ldots, n_k, t)$ is the coded integer of state and registers of $P$ at time $t$ for input $n_1, \ldots, n_k$ and start state $n_0$ (here $=1$).

In particular, for $t=0, h=2^{n_0}3^{n_1}\ldots p_k^{n_k}$. For recursion for $h$, we need $s:\N\rightarrow\N$, the ``transition function", which computes in coded form the changes at each step.
\end{proof}

\subsection*{Algorithms and Recursive Sets}
A function $f:\N^k \rightarrow \N$ is \emph{recursive} or \emph{computable} if it is total. If it s not even partial recursive, then it is \emph{incomputable}.

A subset $X\subseteq \N^k$, (often $X\subseteq \N$) is \emph{recursive} or \emph{computable} or \emph{decidable} if the characteristic function $\chi_X(n) = \begin{cases} 1 & n\in X \\ 0 & n \notin X\end{cases}$ is computable, i.e. if we can program a computer to tell us if a given number is in it or not.

An \emph{algorithm} is any process which takes an input in $\N^k$ for some specified $k$, or a recursive subset $X\subseteq \N^k$, and returns an output in $\N$ which is simulated by a register machine.

A \emph{total algorithm} terminates for all elements in $X$, whilst a \emph{partial algorithm} may fail to terminate for some choices of input.

\begin{lemma}
For each $k\geq 1$, there is some total function $f:\N^k \to \N$ which is incomputable.
\end{lemma}
\begin{proof}
Each computable program comes from a finite program with $n+1$ states for some $n$. Since there are only countably many finite programs, but $\powset(\N)$ is uncountable, hence one of these sets is not computable. Then its indicator function is not computable.
\end{proof}

For given $m$, the \emph{shortlex} ordering on $\N^m$ is $(n_1,\ldots, n_m) < (n_1', \ldots, n_m')$ if $\sum n_i < \sum n_i'$ or $\sum n_i = \sum n_i$ and there is some $j$ with $n_i = n_i'$ for $i<j$, but $n_{j+1} > n'_{j+1}$.

This gives us a bijection to $\N$, as there are only finitely many $k$-tuples of naturals with sum less than $N \in \N$.

If a register machine $P$, then for the $i$\th instruction, let $t_i = \begin{cases} 2^j \cdot 5^k & \text{if it is } (j, +, k) \\ 2^j\cdot 3\cdot 5^k \cdot 7^l & \text{if it is } (j,-,k,l)\end{cases}$. We can then encode the tuple $(t_1, t_2, \ldots, t_n)$ as $m=2^n\cdot 3^{t_1}\cdot 5^{t_2} \cdot\ldots \cdot p_n^{t_{n-1}}$. We denote the program encoded by the number $m$ as $P_m$, if $m$ is a valid encoding of a program. For these $m$, we say $m$ \emph{codes} a program, and $P_m$ is the \emph{m\th machine}.

The input for a register machine is a $k$-tuple for varying $k$, so we define $f_{n,k}$ for the $k$-variable function computed by the $n$\th machine if $P_n$ exists.

Here is an explicit total function which is not recursive:
\begin{lemma}
Consider the following function $g:\N\to\N$ given by:
\begin{align*}
g(n) \coloneqq \begin{cases} f_{n,1}(n) + 1 & \text{if $n$ codes a program and if $f_{n,1}(n)$ is defined} \\ 0 & \text{else}\end{cases}
\end{align*}
Then $g$ is not recursive.
\end{lemma}
\begin{proof}
If $g$ is recursive then it is computed by some machine. So there exists an $N$ such that $g = f_{N,1}$ is total. But then $f_{N,1}(N) = g(N) = f_{N,1}(N) + 1$ \contr.
\end{proof}

\subsection*{Church's Thesis}
The two key figures in this chapter are Alonzo Church and Alan Turing, doing this work around 1936.

An \emph{executable process} is a step-by-step deterministic process with finite description at each step, a finite set of rules, and a finite amount of input and output.

An \emph{abstract theory of finite computation} is a theory of computation consisting of these executable processes.

\begin{theorem}[Church's Thesis]\item
\begin{enumerate}
\item In any abstract theory of finite computation, $\mathscr{C}$, the $\mathscr{C}$-partial computable function $f:\N^k \to \N$ gives at most the partial recursive functions.
\item Any informal description of an executable process starting with input in $\N^k$ and output in $\N$ or never halting is equivalent to a register machine, so we don't need to worry about all the details of the machine.
\item There is a total algorithm, that, given the encoding (e.g. shortlex) of a description of an algorithm, returns a code for a register machine that carries out this process.
\end{enumerate}
\end{theorem}
This is not so much one theorem as many different independent theorems. It has however been proven that all the following abstract theories of finite computation are equivalent:
\begin{itemize}
\item Church's $\lambda$-calculus
\item Turing machines
\item Register machines
\item Standard languages
\item Quantum/DNA-computers
\end{itemize}
From now on, we will refer to these three statements as ``Church's thesis" or even just ``Church". 

\begin{lemma}
Let $h:\N\rightarrow \N$ be:
\begin{align*}
h(n) = \begin{cases}f_{n,1} (n) + 1 & \text{if $n$ codes a program and $f_{n,1}(n)$ defined} \\ \text{undefined} & \text{otherwise}\end{cases}
\end{align*}
Then $h$ is partial recursive.
\end{lemma}

\begin{proof}
For input $n$, check if $n$ codes a program - this is total recursive. If so, run the program with input $n$. If it then halts, add $1$ to $R_1$ and halt, and so by Church $h$ is partial computable = partial recursive.
\end{proof}

\subsection*{Recursively Enumerable Sets}
Given a partial recursive function $f:\N^k \to \N$ with domain $X\subseteq \N^k$, suppose we input $7$. If $f(7)\downarrow$, then we can run the machine and get the answer within finite time. However, if $f(7)\uparrow$, then we will be waiting forever. By the halting problem, there is no way to know in advance what will happen.

Now suppose we ask: ``Does $f$ halt on either $7$ or $9$?" Then the answer is yes, but if we are unlucky and start with $9$, we will never know if we na\"ively compute $f(9)$, then $f(7)$. 

So instead, we zig-zag: we do one step of each alternately.\\
Let $P_n^t(x)$ be the $t\th$ step of $P_n$ with input $x$. Then we can do:
\begin{center}
\tikz{
\node (1) at (0,3) {$P_n^1(7)$};
\node (2) at (4,3) {$P_n^1(9)$};
\node (3) at (0,2) {$P_n^2(7)$};
\node (4) at (4,2) {$P_n^2(9)$};
\node (5) at (0,1) {$P_n^3(7)$};
\node (6) at (4,1) {$P_n^3(9)$};
\node (7) at (0.5,0.2) {};
\draw[->] (1) edge (2) (2) edge (3) (3) edge (4) (4) edge (5) (5) edge (6);
\draw[dotted, ->] (6) edge (7);
}
\end{center}
We can clearly extend this to any set of finite size. We can even do infinite sets, by following a path similar to in the textbook enumeration of $\Q$:
\begin{center}
\tikz{
\node (1) at (0,3) {$P_n^1(1)$};
\node (2) at (2,3) {$P_n^1(2)$};
\node (3) at (0,2) {$P_n^2(1)$};
\node (4) at (0,1) {$P_n^3(1)$};
\node (5) at (2,2) {$P_n^2(2)$};
\node (6) at (4,3) {$P_n^1(3)$};
\node (7) at (4,2) {$P_n^2(3)$};
\node (8) at (2.5,1.2) {};
\draw[->] (1) edge (2) (2) edge (3) (3) edge (4) (4) edge (5) (5) edge (6) (6) edge (7);
\draw[dotted, ->] (7) edge (8);
}
\end{center}
We can even alternate between different machines, and this process can be extended to any countable set. Then by Church, we can write a program that returns $1$ for input $x \in \N^k, k < \infty$ if some partial recursive function $f$ halts on input of $x$.

We say a set $E\subseteq \N^k$ is \emph{recursively enumerable} if the function
\begin{align*}
\phi_E(n) \coloneqq \begin{cases} 1 & n\in E \\ \uparrow&  \text{else}\end{cases}
\end{align*}

The idea behind this definition is that, compared to a recursive set, here we can only say that $x$ is in $E$, whereas in a recursive set we can say if $x \in E$ or $x \notin E$. A consequence of this is that, by applying the above process for $\phi_E$ on all of $\N^k$, we will eventually get out all the elements of $E$, but we will not know when this has happened (indeed, it might take infinitely long to get all the elements, but we will eventually be notified that any given element is in $E$), so we can ``recursively enumerate" $E$. Conversely, recursive sets are often called \emph{decidable} - we can always decide whether or not $x \in E$. We will cement this discussion into a few theorems now:

\begin{theorem}
The following are equivalent for any subset $E \subseteq \N$:
\begin{enumerate}
\item $E$ is the range of some partial recursive function on some number of variables, i.e.\\ $E = \{f_{n,k}(\mathbf{x}) : \mathbf{x} \in \N^k\}$
\item $E$ is the domain of definition of some partial recursive function on $1$ variable, i.e.:
$\exists n \st E = \{m\in\N : f_{n,1}(m)\downarrow\}$
\item $E$ is recursively enumerable
\item The function $\psi_E(n) = \begin{cases} n & n \in E \\ \uparrow & \ow \end{cases}$ is partial recursive. i.e. we can enumerate the elements of $E$ in a recursive fashion.
\end{enumerate}
\end{theorem}
\begin{proof}\item
\begin{itemize}
\item{\imp{2}{3}} Given a program $P_n$ for computing $f_{n,1}$, modifying at end so it empties $R_1$ then adds $1$.
\item{\imp{3}{4}} Similarly, we start by copying $R_1$ to $R_N$ for large enough $N$, then at the end empty $R_1$ and copy $R_N$ to $R_1$.
\item{\imp{4}{1}} Immediate as $f_{n,k} = \psi_E$ for some choice of $n$, $k=1$.
\item{\imp{1}{2}} Given a program $P_n$ for computing $f_{n,k}:\N^k \to \N$ with range $E$, do the following process $Q$ by Church:

Given an input $x\in \N$ for $Q$, run a zig-zag procedure having ordered $\N^k$ to compute $f_{n,k}(\cdot)$ for each input $\cdot \in \N^k$. Each time, $f_{n,k}(m_1,\ldots, m_k)$ halts, run the total subroutine comparing the output to $x$ wand halt with output $1$ if equal. If not, return to the zig-zag process. So $Q$ will return $1$ if $x$ is in the range $f_{n,k}$, and if not will run forever, because we would never get an output equalling $x$.
\end{itemize}
\end{proof}

\subsection*{Properties of Recursively Enumerable Sets}
In \textbf{1.10}(\textit{1.}), can we have a total recursive function?
\begin{theorem}
If $E \neq \emptyset$ and $E\subseteq \N$, then $E$ is recursively enumerable if and only if $E$ is the range of a total recursive function $f:\N \to \N$.
\end{theorem}
\begin{proof}
For $E = \{e_0, \ldots, e_{k-1}\}$ finite, define $f(n)\coloneqq \begin{cases} e_n & n <k \\ e_{k-1} & \ow\end{cases}$. This is total recursive.

In the case of infinite $E \subseteq \N$ which is the domain of a partial recursive function $g:\N \to \N$, run a zig-zag process to perform the steps of computing $g(0), g(1), \ldots$. Define a total function $f:\N\to\N$ as $f(0)$ is the first input number $i$ for which the computation of $g(i)$ halts in this process (not necessarily the smallest), $f(1)$ the second, and so on. Thus the range of $f$ is $E$ and $f$ is recursive by Church.
\end{proof}

So each program $P_n$ corresponds to a recursively enumerable set which is the domain of $f_{n,1}$. Thus let $W_n = \{x\in\N : f_{n,1}(x) \downarrow \}$ if $n$ encodes a program, and the empty set otherwise. We say $W_n$ is the \emph{n\th recursively enumerable set}, though the labelling is not unique, i.e. it could be that $W_n = W_m$ for some $n\neq m$.

Every recursive subset is recursively enumerable by definition. However:
\begin{theorem}
For any $E\subseteq \N$, $E$ is recursive if and only if $E$ and $\N\setminus E$ is recursively enumerable.
\end{theorem}
\begin{proof}\item
\begin{itemize}
\item{\underline{$\implies$}} As $\chi_E$ is total recursive, $\phi_E$ is partial recursive because when $\chi_E$ halts, if the output is 1 then halt, otherwise enter an infinite loop. We can do the same for $\N\setminus E$, to get $\phi_E, \phi_{\N\setminus E}$.
\item{\underline{$\impliedby$}} As $\phi_E$ and $\phi_{\N\setminus E}$ are both partial recursive, we can do a zig-zag process between the two. Then, if $\phi_E(x)$ halts, return $1$, otherwise if $\phi_{\N\setminus E}(x)$ halts, return $0$. Since $E \cup \N\setminus E = \N$, exactly one of these will halt, and so this gives $\chi_E$ which is total recursive.
\end{itemize}
\end{proof}

\begin{theorem}\item
\begin{enumerate}
\item If $I \subseteq \N$ is recursively enumerable, then the union $\cup_{n\in I} W_n$ is recursively enumerable.
\item If $J \subseteq \N$ is finite, then $\cap_{n\in J} W_n$ is recursively enumerable.
\end{enumerate}
\end{theorem}
\begin{proof}\item
\begin{itemize}
\item[\textit{1.}] We want a process that, given an input $x \in \N$, halts if $x \in \cup_{n\in I}W_n$, and not if $x \notin \cup_I W_n$.

By a big zig-zag process, start outputting elements $n$ of $I$, test if $n$ codes a program $P_n$, move on if not but if so, start to run $P_n$ on this input $x$. One of these subprocesses halts if and only if $x \in W_n$ for some $n \in I$, in which case halt the whole process. However, if $x \notin \cup_I W_n$, then the process will run forever.

\item[\textit{2.}] First check all the $j \in J$ code a program, else we have $\emptyset$. Then run these $|J|$ programs in parallel, each with input $x$. If/when all of these halt, then halt. Then we halt if and only if $x \in \cap_J W_n$.;;
\end{itemize}
\end{proof}
\end{document}
